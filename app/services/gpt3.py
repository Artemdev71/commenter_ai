import json
import logging
import requests
from flask import request
from configparser import ConfigParser
#from app import app

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)s] %(message)s'))
logger.addHandler(handler)
config = ConfigParser()
config.read('config/keys_config.cfg')
API_KEY = config.get('gpt3', 'api_key')


#@app.route("/gpt3", methods=["POST"])
def generate_text():
    """
    Endpoint that generates text based on the specified emotion.
    """
    try:
        
        # authorization check is commented and will be enabled when api integeration will be tested
        
        # access_token = request.headers.get("Authorization")
        # if not access_token:
        #     return "Access token not found in header", 401
        # access_check_response = requests.post("http://access_check_api.com/check", headers={"Authorization": access_token})
        # if access_check_response.status_code != 200:
        #     return "Access denied", 401
                
        # Extract the emotion from the request
        emotion = request.json['emotion']
        prompt = request.json['prompt']
        platform = request.json['platform'].lower()
        keywords = request.json.get('keywords', [])
        
        
        # Define the maximum length of the post for each platform
        platform_limits = {
            "facebook": (50, 260),
            "linkedin": (70, 350),
            "twitter": (40, 280),
        }
        
        if platform not in platform_limits:
            return "Error: unsupported platform", 400
        
        max_words, max_characters = platform_limits[platform]
               

        # Define the prompt based on the emotion
        emotion_map = {
            "funny": "Compose a humorous and entertaining comment, showcasing your wit and lightheartedness",
            "serious": "Write a concise and insightful comment, demonstrating your knowledge and understanding of the topic",
            "sarcastic": "Create a witty and sarcastic comment, showcasing your sense of humor",
            "provocative": "Generate a provocative and thought-provoking comment, challenging conventional perspectives",
            "controversial": "Compose a controversial and bold comment, addressing a sensitive or divisive issue",
        }
        
         default_prompt = "Craft a unique,human-like comment to the following LinkedIn post The comment should not rephrase any part of the post but introduce a fresh perspective or idea that stimulates discussion, while remaining engaging and relevant Ensure to follow LinkedIn's best practices"
        #default_prompt = "Create a unique and thought-provoking comment, showcasing your creativity and knowledge of the topic"
        if keywords:
            prompt = emotion_map.get(emotion.lower(), default_prompt)+" on the following post \n" + prompt + "\n based on these keywords: "+", ".join(keywords) + "\n The comment shouldnot be longer than "+ str(max_words-10) + " words."  
        else:
            prompt = emotion_map.get(emotion.lower(), default_prompt)+" on the following post \n" + prompt + "\n The comment shouldnot be longer than "+ str(max_words-10) + " words."

        # Define the API key and the endpoint URL
        api_key = API_KEY
        # model = "text-davinci-003"
        model = "gpt-3.5-turbo"
        # url = f"https://api.openai.com/v1/engines/{model}/jobs"  depreciated
        # url = "https://api.openai.com/v1/completions"
        url = f"https://api.openai.com/v1/chat/completions"
        

        # Define the headers for the API request
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}"
        }
        
        
        # Define the data for the API request
        data = {
            # "prompt": prompt,
            "messages": [{"role": "user", "content": prompt}],
            "model": model,
            "temperature": 0.7,
            "top_p": 0.95,
            "max_tokens": max_words,
            # "max_chars": max_characters,
            "presence_penalty": 0.8,
            "frequency_penalty": 0.7,             
            "n":1
        }

        # Send the API request
        # logger.info(f"prompt is: {prompt}")
        response = requests.post(url, headers=headers, data=json.dumps(data))
        # hh=data['prompt']
        # logger.info(f"prompt: {hh}")
        # Check if the request was successful
        if response.status_code != 200:
            # hh=data['prompt']
            # logger.info(f"prompt: {hh}")
            raise Exception(f"Error accessing OpenAI API, status code: {response.status_code}")

        # Extract the text generated by the API
        result = response.json()
        # generated_text = result['choices'][0]['text']
        generated_text = result['choices'][0]['message']['content']

        # Log a message indicating that text generation was successful
        logger.info(f"Generated text: {generated_text}")

        # Return the generated text
        return generated_text, 200

    except Exception as e:
        # Log an error message if an exception was raised
        logger.error(f"Error generating text: {str(e)}")

        # Return a 500 Internal Server Error response
        return "Error generating text", 500

if __name__ == "__main__":
    print("")
